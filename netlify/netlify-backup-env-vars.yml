name: Backup Netlify Environment Variables to Azure Key Vault

trigger: none

schedules:
  - cron: '0 2 * * *'
    always: true
    branches:
      include:
        - main
    displayName: Daily Environment Variable Backup

pool:
  vmImage: 'ubuntu-22.04'

variables:
  - group: Netlify-TF-Credentials
  
steps:
  - checkout: none
  - task: AzureCLI@2
    displayName: 'Backup Netlify Environment Variables to Azure Key Vault'
    inputs:
      azureSubscription: 'ADO-PWD-Connection'
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      inlineScript: |
        $setSecrets = @()
        $completeAppCount = 0
        $env:NETLIFY_AUTH_TOKEN="$(NETLIFY_API_TOKEN)"

        $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $headers.Add("Authorization", "Bearer $(NETLIFY_API_TOKEN)")
        $sites = (netlify sites:list --json) | ConvertFrom-Json
        foreach ($site in $sites) {
            $completeAppCount++
            Write-Output ('Backing up App {0} of {1} - {2}' -f $completeAppCount,$sites.Count,$site.name)
            $envVars = Invoke-RestMethod ('https://app.netlify.com/access-control/bb-api/api/v1/accounts/668bdcc086b4e91c25541ac1/env?site_id={0}&scope=all&context=all&level=all' -f $site.Id) -Method 'GET' -Headers $headers
            
            foreach ($var in $envVars) {
                foreach ($val in $var.values) {
                    $context = $val.context
                    if ($val.context_parameter) {
                        $context += ':{0}' -f $val.context_parameter
                    }

                    if ($val.value) {
                        $secretName = ('{0}---{1}---{2}' -f $site.id.split('-')[0], $var.key, $context).Replace('_', '-US-').Replace(':', '-CLN-').Replace('.', '-DOT-').Replace('/', '-FSLSH-')
                        $setSecrets += $secretName
                        try { 
                            $existingSecretValue = az keyvault secret show --vault-name maps-apps-var-backup --name $secretName | ConvertFrom-Json
                            if ($existingSecretValue.value -ne ('"{0}"' -f $val.value)) {
                                Write-Output ('Updating Secret {0} in context {1}' -f $var.key,$context)
                                $setResult = az keyvault secret set --vault-name maps-apps-var-backup --name $secretName --value $val.value
                            }
                        }
                        catch {                
                            Write-Output ('Creating Secret {0} in context {1}' -f $var.key,$context)
                            $setResult = az keyvault secret set --vault-name maps-apps-var-backup --name $secretName --value $val.value
                        }
                    }
                }
            }
        }


        $existingSecrets = az keyvault secret list --vault-name maps-apps-var-backup | ConvertFrom-Json
        $existingSecretsNames = $existingSecrets | foreach { $_.name }

        $secretsToDelete = $existingSecretsNames | Where-Object { $_ -notin $setSecrets }
        foreach ($secretToDelete in $secretsToDelete) {
            Write-Output ('Removing secret {0}' -f $secretToDelete)
            az keyvault secret delete --vault-name maps-apps-var-backup --name $secretToDelete
            az keyvault secret purge --vault-name maps-apps-var-backup --name $secretToDelete
        }